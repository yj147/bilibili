# Component Guidelines

> Component patterns and conventions in Bili-Sentinel frontend.

---

## Component Categories

### 1. Page Components (`app/{feature}/page.tsx`)
- Always `"use client"` (SWR requires client rendering)
- Fetch data with SWR hooks, mutate with api client

### 2. Shared Components (`components/`)
- Reusable across pages: `Sidebar`, `ErrorBoundary`, `QRLoginModal`, `ConfirmDialog`

### 3. UI Primitives (`components/ui/`)
- Generated by shadcn/ui CLI, Radix UI based
- Do not modify directly

---

## Styling Conventions

### Design System
- **Theme**: Light mode, B站-inspired (`bg-background`, `text-foreground`)
- **Primary**: B站粉 `#fb7299` — buttons, active states, accents
- **Accent**: B站蓝 `#00a1d6` — secondary highlights
- **Cards**: shadcn `<Card>` with `card-elevated` (hover shadow + translateY) or `card-static` (subtle shadow)
- **Background**: `bg-gradient-subtle` (pink → gray → blue gradient at 135deg)
- **Sidebar**: `bg-gradient-sidebar` with `shadow-pink-glow` on logo
- **Status colors**: Green=active, Red=failed, Blue=connected, Yellow=warning
- **Animations**: Framer Motion for enter/exit, CSS for ongoing
- **Typography**: Geist Sans + Geist Mono

### Tailwind Patterns
```tsx
// Card with hover elevation
<Card className="card-elevated">

// Status indicator
<div className={`w-2 h-2 rounded-full ${isActive ? 'bg-green-500' : 'bg-red-500'}`} />

// Use cn() for conditional classes
import { cn } from "@/lib/utils";
<div className={cn("base", isActive && "active")} />
```

### CSS Utility Classes (globals.css)
| Class | Effect |
|-------|--------|
| `card-elevated` | Subtle shadow + hover: deeper shadow + translateY(-1px) |
| `card-static` | Subtle shadow only (no hover effect) |
| `shadow-pink-glow` | Pink glow shadow (`rgba(251,114,153,0.2)`) |
| `bg-gradient-subtle` | Page background gradient (pink → gray → blue) |
| `bg-gradient-sidebar` | Sidebar gradient (white → off-white) |

### Responsive Design
- Mobile-first with `md:` breakpoint
- Sidebar: hidden mobile, fixed 64px desktop
- Main content: `md:ml-64` offset
- Grids: `grid-cols-1 md:grid-cols-4`

---

## Animation Patterns

### Framer Motion
```tsx
<motion.div initial={{ height: 0 }} animate={{ height: `${v}%` }} transition={{ delay: i * 0.05 }} />
```

### CSS Animations
```tsx
<span className="animate-pulse" />           // Active indicators
<RefreshCw className={loading ? "animate-spin" : ""} />  // Loading
```

---

## Common Mistakes

1. **Forgetting "use client"** — SWR hooks require it
2. **Modifying shadcn/ui files directly** — customize via className props
3. **Using Server Components for interactive pages** — all feature pages are client components

---

## Toast Notification Pattern

Use `sonner` for transient user notifications:

```tsx
import { toast, Toaster } from "sonner";

// In handlers
toast.success("操作成功");
toast.error("操作失败");
toast.warning("Cookie 即将过期");

// In JSX (once per page, at bottom)
<Toaster richColors />
```

### Toast Deduplication via useRef

Prevent duplicate toasts on SWR re-render using a `Set` ref:

```tsx
const notifiedRef = useRef(new Set<number>());

useEffect(() => {
  accounts?.forEach(acc => {
    if (acc.status === "expiring" && !notifiedRef.current.has(acc.id)) {
      notifiedRef.current.add(acc.id);
      toast.warning(`[${acc.name}] Cookie 即将过期`);
    }
  });
}, [accounts]);
```

**Why**: SWR triggers re-renders on revalidation. Without dedup, the same toast fires repeatedly.

---

## Confirmation Dialog Pattern

Use `useConfirm` hook (`components/ConfirmDialog.tsx`) for destructive action confirmations:

```tsx
import { useConfirm } from "@/components/ConfirmDialog";

const { confirm, ConfirmDialog } = useConfirm();

const handleDelete = async (id: number) => {
  if (!await confirm({ description: "确定删除？", variant: "destructive", confirmText: "删除" })) return;
  await api.items.delete(id);
  mutate();
};

// In JSX (once per page)
<ConfirmDialog />
```

> **Warning**: Do NOT use native `confirm()` or `alert()`. Always use shadcn AlertDialog via `useConfirm`.

---

## QR Login Modal Pattern

QR login is a multi-step flow with state machine:

| State | Display |
|-------|--------|
| `loading` | Spinner |
| `waiting` | QR code image |
| `scanned` | "已扫码，请确认" |
| `success` | Green checkmark, auto-close |
| `expired` | "已过期" + refresh button |
| `error` | Error message + retry |

**Key**: The modal is conditionally rendered (not hidden via CSS), so mount/unmount triggers cleanup of polling intervals.

---

## Edit Modal Pattern

CRUD pages follow a consistent pattern for edit modals using shadcn Dialog:

```tsx
const [editingItem, setEditingItem] = useState<Item | null>(null);
const [editForm, setEditForm] = useState({ field1: '', field2: '' });

// Open modal with pre-filled data
const handleEdit = (item: Item) => {
  setEditForm({ field1: item.field1, field2: item.field2 });
  setEditingItem(item);
};

// Save and close
const handleSave = async () => {
  await api.items.update(editingItem!.id, editForm);
  mutate(); // SWR revalidation
  setEditingItem(null);
};

// shadcn Dialog for modals
<Dialog open={showEditModal && !!editingItem} onOpenChange={setShowEditModal}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle>编辑</DialogTitle>
    </DialogHeader>
    {/* Form content */}
  </DialogContent>
</Dialog>
```

---

## Mobile-Friendly Action Buttons

Action buttons that appear on hover must remain visible on touch devices:

```tsx
// Good — visible on mobile, hover-reveal on desktop
<div className="opacity-100 md:opacity-0 md:group-hover:opacity-100 transition">
  <button>Edit</button>
  <button>Delete</button>
</div>

// Bad — invisible on mobile
<div className="opacity-0 group-hover:opacity-100">
```

---

## WebSocket Development Mode

The WebSocket hook connects directly to the backend in development, bypassing the Next.js proxy (which does not support WebSocket upgrade):

```typescript
const isDev = process.env.NODE_ENV === 'development';
const wsUrl = process.env.NEXT_PUBLIC_WS_URL
  || (isDev ? 'ws://localhost:8000' : `${protocol}//${window.location.host}`);
```

In production (behind a reverse proxy that handles WS), it uses the page host.
